# Проблема "алмаза" (или "ромбовидная проблема") возникает
# в объектно-ориентированном программировании при использовании множественного
# наследования, когда два класса B и C наследуются от одного класса A,
# а класс D наследуется от обоих классов B и C.

# Если в классах B и C переопределен метод из класса A, а D не имеет
# собственной реализации этого метода,
# возникает неоднозначность: какой метод вызывать?


# Структура проблемы "алмаза"
#
#     A
#    / \
#   B   C
#    \ /
#     D
#
#     Класс A содержит метод do_something.
#     Классы B и C наследуются от класса A и оба переопределяют метод
#     do_something.
#     Класс D наследует от классов B и C.
#
# Если создать экземпляр класса D и вызвать метод do_something,
# возникает вопрос: какую реализацию метода следует использовать — из B или C?

class A:
    def do_something(self):
        print("Method defined in: A")


class B(A):
    def do_something(self):
        print("Method defined in: B")


class C(A):
    def do_something(self):
        print("Method defined in: C")


class D(B, C):
    pass


d_instance = D()
d_instance.do_something()
print(D.mro())


# В языках программирования, которые поддерживают множественное наследование,
# как Python, этот вопрос решается с помощью специфичного
# порядка разрешения методов (MRO).
#
# Python использует алгоритм C3 линеаризации для решения проблемы "алмаза".
# Этот алгоритм гарантирует, что порядок, в котором классы были указаны
# при объявлении наследования, будет учитываться, и родительский класс будет
# обработан только после его дочерних классов.
#
# Как работает C3 Linearization
#
# Алгоритм C3 упорядочивает классы, используя простой, но эффективный подход.
# Он рекурсивно объединяет списки предков каждого класса с сохранением
# порядка и без дублирования, пока не будет создан полный линейный порядок.
#
# Процесс можно описать следующим образом:
#
#     Начните с класса, для которого необходимо вычислить линеаризацию
#       (часто это подкласс).
#     Поместите этот класс в линеаризированный список.
#     Продолжайте добавлять классы из списков предков, начиная с
#       непосредственных родителей, затем их родителей и так далее.
#     При каждом выборе класса убедитесь, что этот класс не является
#       подклассом никакого из ещё не добавленных классов в линеаризированный
#       список.

# В нашем случае порядок MRO для класса D будет таким: D, B, C, A.
# Следовательно, метод do_something класса B будет вызван первым,
# потому что класс B указан перед классом C при определении класса D.


# Что произойдёт в коде ниже?

class A:
    pass


class B(A):
    pass


class C(A):
    pass


class D(B, C):
    pass


class E(C, B):
    pass


class F(D, E):
    pass

